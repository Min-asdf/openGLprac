#include <GL/freeglut.h>
#include <cmath>

//모델링 모드 부울 변수
int FlatShaded = 0;
int Wireframed = 0;

//마우스로 시점 회전 및 거리 이동
float yaw = 0.0f, pitch = 0.0f;
float camDist = 3.0f;

//마우스 드래그 상태
int lastX = -1, lastY = -1;
const float ROT_SPEED = 0.005f;

//콜백 함수
void MyDisplay();
void InitLight();
void MyMouseMove(GLint X, GLint Y);
void MyMouseButton(int button, int state, int x, int y);
void MyMouseWheel(int wheel, int direction, int x, int y);
void MyKeyboard(unsigned char KeyPressed, int X, int Y);
void MyReshape(int w, int h);

//메인 함수
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    //더블버퍼 + 깊이 버퍼
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
    glutInitWindowSize(400, 400);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("OpenGL Camera Rotate Sample");

    glClearColor(0.4f, 0.4f, 0.4f, 0.0f);
    glEnable(GL_DEPTH_TEST);
    //조명 계산 안정화(스케일에 영향 줄이기)
    glEnable(GL_NORMALIZE);

    InitLight();

    glutDisplayFunc(MyDisplay);
    glutKeyboardFunc(MyKeyboard);
    glutMotionFunc(MyMouseMove);
    glutMouseFunc(MyMouseButton);
    glutMouseWheelFunc(MyMouseWheel);
    glutReshapeFunc(MyReshape);

    glutMainLoop();
    return 0;
}

//디스플레이 함수
void MyDisplay() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // yaw/pitch로 eye 구하기 (구면좌표 → 직교좌표)
    // yaw: 수평, pitch: 수직
    float cp = cosf(pitch), sp = sinf(pitch);
    float cy = cosf(yaw), sy = sinf(yaw);
    float eyeX = camDist * cp * sy;
    float eyeY = camDist * sp;
    float eyeZ = camDist * cp * cy;

    // 카메라: (eye) → 원점(0,0,0) 바라봄, up=(0,1,0)
    gluLookAt(eyeX, eyeY, eyeZ, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    GLfloat light_position[] = { -3.0f, 6.0f, 3.0f, 0.0f };
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    // 폴리곤 모드 (wireframe 토글)
    glPolygonMode(GL_FRONT_AND_BACK, Wireframed ? GL_LINE : GL_FILL);

    // 도형 그리기
    glutSolidTeapot(0.5);

    glutSwapBuffers();
}

//조명 함수
void InitLight() {
    GLfloat mat_diffuse[] = { 0.5f, 0.4f, 0.3f, 1.0f };
    GLfloat mat_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat mat_ambient[] = { 0.5f, 0.4f, 0.3f, 1.0f };
    GLfloat mat_shininess[] = { 15.0f };

    GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.0f };
    GLfloat light_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat light_ambient[] = { 0.3f, 0.3f, 0.3f, 1.0f };
    GLfloat light_position[] = { -3.0f, 6.0f, 3.0f, 0.0f };

    glShadeModel(FlatShaded ? GL_FLAT : GL_SMOOTH);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);

    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

//마우스 버튼 함수
void MyMouseButton(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) { lastX = x; lastY = y; }
        else { lastX = -1; lastY = -1; }
    }
}

//마우스 이동 함수
void MyMouseMove(GLint X, GLint Y) {
    if (lastX >= 0 && lastY >= 0) {
        int dx = X - lastX;
        int dy = Y - lastY;
        lastX = X;
        lastY = Y;

        yaw -= dx * ROT_SPEED;
        pitch += dy * ROT_SPEED;
        const float limit = 1.553343f;
        if (pitch > limit) pitch = limit;
        if (pitch < -limit) pitch = -limit;

        glutPostRedisplay();
    }
}

//마우스 휠 함수
void MyMouseWheel(int /*wheel*/, int direction, int /*x*/, int /*y*/) {
    camDist += (direction < 0 ? 0.2f : -0.2f);
    if (camDist < 0.5f) camDist = 0.5f;
    if (camDist > 20.0f) camDist = 20.0f;
    glutPostRedisplay();
}

//키보드 함수
void MyKeyboard(unsigned char KeyPressed, int, int) {
    switch (KeyPressed) {
    case 'Q': case 'q': case 27:
        exit(0);
        break;

        //솔리드 프레임
    case 's':
        FlatShaded = !FlatShaded;
        glShadeModel(FlatShaded ? GL_FLAT : GL_SMOOTH);
        glutPostRedisplay();
        break;

        //와이어 프레임
    case 'w':
        Wireframed = !Wireframed;
        glutPostRedisplay();
        break;

        //줌인
    case '+':
        camDist -= 0.2f; if (camDist < 0.5f) camDist = 0.5f;
        glutPostRedisplay();
        break;
        //줌아웃
    case '-':
        camDist += 0.2f; if (camDist > 20.0f) camDist = 20.0f;
        glutPostRedisplay();
        break;
    }
}

//Reshape 함수
void MyReshape(int w, int h) {
    if (h == 0) h = 1;
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat)w / (GLfloat)h, 0.1, 100.0);

    glMatrixMode(GL_MODELVIEW);
}
